<?php
/**
 * Created by PhpStorm.
 * User: liser
 * Date: 08.02.2019
 * Time: 1:25
 */
include "SaleProduct.php";

$prod1 = new Product(1, "MANGO People", 68, "T-Shirts", "Brand");
$saleProd = new SaleProduct(2, "BRAND People", 70, "T-Shirts", "Adidas", "26.02.2019", "5" );

$prod1->showProductInfo();
$saleProd->showProductInfo();

// Задание 5:
// Дан код:

class A {
    public function foo() {
        static $x = 0;
        echo ++$x."<br>";
    }

}

$a1 = new A();
$a2 = new A();
$a1->foo(); // Выведет 1
$a2->foo(); // Выведет 2
$a1->foo(); // Выведет 3
$a2->foo(); // Выведет 4

// Что он выведет на каждом шаге? Почему?
// Ответ: Так как у нас статическая переменная, она имеет везде одинаковое значение
// Префиксный искремент возвращает модифицированное значение "x", у всех экземпляров класса 1.

// Задание 6:
// Немного изменим п.5:

class B extends A {
}
$a1 = new A();
$b1 = new B();
$a1->foo(); // Выведет 5
$b1->foo(); // Выведет 1
$a1->foo(); // Выведет 3
$b1->foo(); // Выведет 4

// Объясните результаты в этом случае.
// static класса A связан со своими сущностями и не будет влиять на B. B, хоть и наследник A, но это уже
// другая ветка, создающая другие сущности. И при наследовании, значение переменной x устанавливается в ноль
// static класса B связан со своими экземплярами

// Задание 7:
// *Дан код:

class D extends A {
}
$a1 = new A;
$d1 = new D;
$a1->foo();
$d1->foo();
$a1->foo();
$d1->foo();

// Ответ: Если конструктор класса не принимает никаких аргументов, то скобки можно опустить
// Результат задание 7 не будет отличаться от результата задания 6.
